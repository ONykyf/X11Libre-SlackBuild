--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/common/Match.c.orig	2025-07-01 18:59:34.391673831 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/common/Match.c	2025-07-01 19:14:15.220160020 +0300
@@ -0,0 +1,116 @@
+/*
+ * Match an attribute against a pattern. Matching mode is
+ * determined by pattern->mode member. If the mode is REGEX,
+ * then regex_t is allocated and compiled only during
+ * the first call, to save time and memory.
+ */
+
+static int
+match_token(const char *attr, xf86MatchPattern *pattern)
+{
+    if ((!pattern) || (!attr))
+        return 0;
+
+    switch (pattern->mode)
+    {
+        case MATCH_IS_INVALID:
+            return 0;
+        case MATCH_IS_STRCMP:
+            return (strcmp(attr, pattern->str)) ? 0 : -1;
+        case MATCH_IS_STRCASECMP:
+            return (strcasecmp(attr, pattern->str)) ? 0 : -1;
+        case MATCH_IS_STRSTR:
+            return (strstr(attr, pattern->str)) ? -1 : 0;
+        case MATCH_IS_STRCASESTR:
+            return (strcasestr(attr, pattern->str)) ? -1 : 0;
+#ifdef HAVE_FNMATCH_H
+        case MATCH_IS_FILENAME:
+            return (fnmatch(pattern->str, attr, 0)) ? 0 : -1;
+        case MATCH_IS_PATHNAME:
+            return (fnmatch(pattern->str, attr, FNM_PATHNAME)) ? 0 : -1;
+#else
+        case MATCH_IS_FILENAME:
+            return (strstr(attr, pattern->str)) ? -1 : 0;
+        case MATCH_IS_PATHNAME:
+            return (strstr(attr, pattern->str)) ? -1 : 0;
+#endif
+        case MATCH_IS_SEQSTR:
+            {
+                char* str = pattern->str;
+                while (*str) {
+                    attr=strstr(attr, str);
+                    if (!attr) return 0;
+                    attr += strlen(str);
+                    str += strlen(str);
+                    str++;
+                }
+            }
+            return -1;
+        case MATCH_IS_REGEX:
+        default:
+#ifdef HAVE_REGEX_H
+            if (pattern->regex == NULL) {
+                int r;
+                if ((pattern->regex = malloc(sizeof(regex_t))) == NULL) {
+                    pattern->mode = MATCH_IS_INVALID;
+                    return 0;
+                }
+                r = regcomp(pattern->regex, pattern->str, REG_EXTENDED | REG_NOSUB);
+                if (r) { /* Wrong regex */
+                    regfree(pattern->regex);
+                    free(pattern->regex);
+                    xf86Msg(X_ERROR, "Wrong regex: \"%s\"\n", pattern->str);
+                    pattern->mode = MATCH_IS_INVALID;
+                    return 0;
+                }
+            }
+            return (regexec(pattern->regex, attr,0, NULL, 0)) ? 0 : -1;
+#else
+            xf86Msg(X_ERROR, "Regex is unavailable at this system: \"%s\"\n", pattern->str);
+            pattern->mode = MATCH_IS_INVALID;
+            return 0;
+#endif
+    }
+}
+
+/*
+ * Match an attribute against a list of xf86MatchGroup's.
+ * Return TRUE only if each list entry is successful.
+ */
+static Bool
+MatchAttrToken(const char *attr, struct xorg_list *groups)
+{
+    xf86MatchGroup *group;
+    xf86MatchPattern *pattern;
+
+    /* If there are no groups, accept the match */
+    if (xorg_list_is_empty(groups))
+        return TRUE;
+
+    /* If there are groups but no attribute, reject the match */
+    if (!attr)
+        return FALSE;
+
+    /*
+     * Otherwise, iterate the list of groups ensuring each entry has a
+     * match. Each list entry is a list of patterns obtained from
+     * a separate Match line.
+     */
+    xorg_list_for_each_entry(group, groups, entry) {
+        Bool match = FALSE;
+
+        xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+            /* It is enough to find one pattern matched by the attribute */
+            match = ((!match_token(attr, pattern)) == pattern->is_negated);
+            if (match)
+                goto group_done;
+        }
+      group_done:
+        if (match == group->is_negated)
+            return FALSE;
+    }
+
+    /* All the entries in the list matched the attribute */
+    return TRUE;
+}
+
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/common/xf86platformBus.c.orig	2025-06-24 18:46:26.000000000 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/common/xf86platformBus.c	2025-07-01 18:59:34.390795849 +0300
@@ -37,6 +37,10 @@
 #include <fcntl.h>
 #include <unistd.h>
 
+#ifdef HAVE_FNMATCH_H
+#include <fnmatch.h>
+#endif
+
 #include "config/hotplug_priv.h"
 #include "dix/screenint_priv.h"
 #include "randr/randrstr_priv.h"
@@ -176,42 +180,7 @@
     return TRUE;
 }
 
-static Bool
-MatchToken(const char *value, struct xorg_list *patterns,
-           int (*compare)(const char *, const char *))
-{
-    const xf86MatchGroup *group;
-
-    /* If there are no patterns, accept the match */
-    if (xorg_list_is_empty(patterns))
-        return TRUE;
-
-    /* If there are patterns but no attribute, reject the match */
-    if (!value)
-        return FALSE;
-
-    /*
-     * Otherwise, iterate the list of patterns ensuring each entry has a
-     * match. Each list entry is a separate Match line of the same type.
-     */
-    xorg_list_for_each_entry(group, patterns, entry) {
-        Bool match = FALSE;
-        char *const *cur;
-
-        for (cur = group->values; *cur; cur++) {
-            if ((*compare)(value, *cur) == 0) {
-                match = TRUE;
-                break;
-            }
-        }
-
-        if (!match)
-            return FALSE;
-    }
-
-    /* All the entries in the list matched the attribute */
-    return TRUE;
-}
+#include "Match.c"
 
 static Bool
 OutputClassMatches(const XF86ConfOutputClassPtr oclass,
@@ -219,7 +188,7 @@
 {
     char *driver = dev->attribs->driver;
 
-    if (!MatchToken(driver, &oclass->match_driver, strcmp))
+    if (!MatchAttrToken(driver, &oclass->match_driver))
         return FALSE;
 
     return TRUE;
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/common/xf86Xinput.c.orig	2025-06-24 18:46:26.000000000 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/common/xf86Xinput.c	2025-07-01 18:59:34.391274718 +0300
@@ -529,88 +529,7 @@
 #endif
 }
 
-static int
-match_substring(const char *attr, const char *pattern)
-{
-    return (strstr(attr, pattern)) ? 0 : -1;
-}
-
-#ifdef HAVE_FNMATCH_H
-static int
-match_pattern(const char *attr, const char *pattern)
-{
-    return fnmatch(pattern, attr, 0);
-}
-#else
-#define match_pattern match_substring
-#endif
-
-#ifdef HAVE_FNMATCH_H
-static int
-match_path_pattern(const char *attr, const char *pattern)
-{
-    return fnmatch(pattern, attr, FNM_PATHNAME);
-}
-#else
-#define match_path_pattern match_substring
-#endif
-
-/*
- * If no Layout section is found, xf86ServerLayout.id becomes "(implicit)"
- * It is convenient that "" in patterns means "no explicit layout"
- */
-static int
-match_string_implicit(const char *attr, const char *pattern)
-{
-    if (strlen(pattern)) {
-        return strcmp(attr, pattern);
-    }
-    else {
-        return strcmp(attr, "(implicit)");
-    }
-}
-
-/*
- * Match an attribute against a list of NULL terminated arrays of patterns.
- * If a pattern in each list entry is matched, return TRUE.
- */
-static Bool
-MatchAttrToken(const char *attr, struct xorg_list *patterns,
-               int (*compare) (const char *attr, const char *pattern))
-{
-    const xf86MatchGroup *group;
-
-    /* If there are no patterns, accept the match */
-    if (xorg_list_is_empty(patterns))
-        return TRUE;
-
-    /*
-     * Iterate the list of patterns ensuring each entry has a
-     * match. Each list entry is a separate Match line of the same type.
-     */
-    xorg_list_for_each_entry(group, patterns, entry) {
-        char *const *cur;
-        Bool is_negated = group->is_negated;
-        Bool match = is_negated;
-
-        /* If there's a pattern but no attribute, we reject the match for a
-         * MatchFoo directive, and accept it for a NoMatchFoo directive
-         */
-        if (!attr)
-            return is_negated;
-
-        for (cur = group->values; *cur; cur++)
-            if ((*compare) (attr, *cur) == 0) {
-                match = !is_negated;
-                break;
-            }
-        if (!match)
-            return FALSE;
-    }
-
-    /* All the entries in the list matched the attribute */
-    return TRUE;
-}
+#include "Match.c"
 
 /*
  * Classes without any Match statements match all devices. Otherwise, all
@@ -620,34 +539,34 @@
 InputClassMatches(const XF86ConfInputClassPtr iclass, const InputInfoPtr idev,
                   const InputAttributes * attrs)
 {
+    const char *layout;
+
     /* MatchProduct substring */
-    if (!MatchAttrToken
-        (attrs->product, &iclass->match_product, match_substring))
+    if (!MatchAttrToken(attrs->product, &iclass->match_product))
         return FALSE;
 
     /* MatchVendor substring */
-    if (!MatchAttrToken(attrs->vendor, &iclass->match_vendor, match_substring))
+    if (!MatchAttrToken(attrs->vendor, &iclass->match_vendor))
         return FALSE;
 
     /* MatchDevicePath pattern */
-    if (!MatchAttrToken
-        (attrs->device, &iclass->match_device, match_path_pattern))
+    if (!MatchAttrToken(attrs->device, &iclass->match_device))
         return FALSE;
 
     /* MatchOS case-insensitive string */
-    if (!MatchAttrToken(HostOS(), &iclass->match_os, strcasecmp))
+    if (!MatchAttrToken(HostOS(), &iclass->match_os))
         return FALSE;
 
     /* MatchPnPID pattern */
-    if (!MatchAttrToken(attrs->pnp_id, &iclass->match_pnpid, match_pattern))
+    if (!MatchAttrToken(attrs->pnp_id, &iclass->match_pnpid))
         return FALSE;
 
     /* MatchUSBID pattern */
-    if (!MatchAttrToken(attrs->usb_id, &iclass->match_usbid, match_pattern))
+    if (!MatchAttrToken(attrs->usb_id, &iclass->match_usbid))
         return FALSE;
 
     /* MatchDriver string */
-    if (!MatchAttrToken(idev->driver, &iclass->match_driver, strcmp))
+    if (!MatchAttrToken(idev->driver, &iclass->match_driver))
         return FALSE;
 
     /*
@@ -661,7 +580,7 @@
         if (!attrs->tags)
             return FALSE;
         for (tag = attrs->tags, match = FALSE; *tag; tag++) {
-            if (MatchAttrToken(*tag, &iclass->match_tag, strcmp)) {
+            if (MatchAttrToken(*tag, &iclass->match_tag)) {
                 match = TRUE;
                 break;
             }
@@ -670,12 +589,17 @@
             return FALSE;
     }
 
-    /* MatchLayout string */
-    if (!xorg_list_is_empty(&iclass->match_layout)) {
-        if (!MatchAttrToken(xf86ConfigLayout.id,
-                            &iclass->match_layout, match_string_implicit))
+    /* MatchLayout string
+     *
+     * If no Layout section is found, xf86ServerLayout.id becomes "(implicit)"
+     * It is convenient that "" in patterns means "no explicit layout"
+     */
+    if (strcmp(xf86ConfigLayout.id,"(implicit)"))
+        layout = xf86ConfigLayout.id;
+    else
+        layout = "";
+    if (!MatchAttrToken(layout, &iclass->match_layout))
             return FALSE;
-    }
 
     /* MatchIs* booleans */
     if (iclass->is_keyboard.set &&
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/InputClass.c.orig	2025-06-24 18:46:26.000000000 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/InputClass.c	2025-07-01 18:59:34.389537600 +0300
@@ -70,6 +70,8 @@
     {-1, ""},
 };
 
+#include "Patterns.c"
+
 static void
 xf86freeInputClassList(XF86ConfInputClassPtr ptr)
 {
@@ -77,64 +79,45 @@
 
     while (ptr) {
         xf86MatchGroup *group, *next;
-        char **list;
 
         TestFree(ptr->identifier);
         TestFree(ptr->driver);
 
         xorg_list_for_each_entry_safe(group, next, &ptr->match_product, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_vendor, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_device, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_os, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_pnpid, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_usbid, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_tag, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_layout, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            free_group(group);
         }
 
         TestFree(ptr->comment);
@@ -148,30 +131,13 @@
 
 #define CLEANUP xf86freeInputClassList
 
-#define TOKEN_SEP "|"
-
-enum MatchType {
-    MATCH_NORMAL,
-    MATCH_NEGATED,
-};
-
-static void
-add_group_entry(struct xorg_list *head, char **values, enum MatchType type)
-{
-    xf86MatchGroup *group = calloc(1, sizeof(xf86MatchGroup));
-    if (group) {
-        group->is_negated = (type == MATCH_NEGATED);
-        group->values = values;
-        xorg_list_add(&group->entry, head);
-    }
-}
-
 XF86ConfInputClassPtr
 xf86parseInputClassSection(void)
 {
     int has_ident = FALSE;
     int token;
-    enum MatchType matchtype;
+    Bool negated;
+    xf86MatchGroup *group;
 
     parsePrologue(XF86ConfInputClassPtr, XF86ConfInputClassRec)
 
@@ -187,7 +153,7 @@
     xorg_list_init(&ptr->match_layout);
 
     while ((token = xf86getToken(InputClassTab)) != ENDSECTION) {
-        matchtype = MATCH_NORMAL;
+        negated = FALSE;
 
         switch (token) {
         case COMMENT:
@@ -217,103 +183,121 @@
             ptr->option_lst = xf86parseOption(ptr->option_lst);
             break;
         case NOMATCH_PRODUCT:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_PRODUCT:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchProduct");
-            add_group_entry(&ptr->match_product,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRSTR, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_product);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_VENDOR:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_VENDOR:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchVendor");
-            add_group_entry(&ptr->match_vendor,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRSTR, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_vendor);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_DEVICE_PATH:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_DEVICE_PATH:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchDevicePath");
-            add_group_entry(&ptr->match_device,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_PATHNAME, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_device);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_OS:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_OS:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchOS");
-            add_group_entry(&ptr->match_os, xstrtokenize(xf86_lex_val.str,
-                                                         TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRCASECMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_os);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_PNPID:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_PNPID:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchPnPID");
-            add_group_entry(&ptr->match_pnpid,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_FILENAME, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_pnpid);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_USBID:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_USBID:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchUSBID");
-            add_group_entry(&ptr->match_usbid,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_FILENAME, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_usbid);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_DRIVER:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_DRIVER:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchDriver");
-            add_group_entry(&ptr->match_driver,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRCMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_driver);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_TAG:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_TAG:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchTag");
-            add_group_entry(&ptr->match_tag, xstrtokenize(xf86_lex_val.str,
-                                                          TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRCMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_tag);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_LAYOUT:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_LAYOUT:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchLayout");
-            add_group_entry(&ptr->match_layout,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRCMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_layout);
+                free(xf86_lex_val.str);
+            }
             break;
         case MATCH_IS_KEYBOARD:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
@@ -396,10 +380,11 @@
 }
 
 void
-xf86printInputClassSection(FILE * cf, XF86ConfInputClassPtr ptr)
+xf86printInputClassSection (FILE * cf, XF86ConfInputClassPtr ptr)
 {
     const xf86MatchGroup *group;
-    char *const *cur;
+    const xf86MatchPattern *pattern;
+    Bool not_first;
 
     while (ptr) {
         fprintf(cf, "Section \"InputClass\"\n");
@@ -411,69 +396,95 @@
             fprintf(cf, "\tDriver          \"%s\"\n", ptr->driver);
 
         xorg_list_for_each_entry(group, &ptr->match_product, entry) {
-            fprintf(cf, "\tMatchProduct    \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchProduct  \"");
+            else                   fprintf(cf, "\tMatchProduct    \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_vendor, entry) {
-            fprintf(cf, "\tMatchVendor     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchVendor   \"");
+            else                   fprintf(cf, "\tMatchVendor     \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_device, entry) {
-            fprintf(cf, "\tMatchDevicePath \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchDevicePath \"");
+            else                   fprintf(cf, "\tMatchDevicePath   \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_os, entry) {
-            fprintf(cf, "\tMatchOS         \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchOS       \"");
+            else                   fprintf(cf, "\tMatchOS         \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_pnpid, entry) {
-            fprintf(cf, "\tMatchPnPID      \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchPnPID    \"");
+            else                   fprintf(cf, "\tMatchPnPID      \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_usbid, entry) {
-            fprintf(cf, "\tMatchUSBID      \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchUSBID    \"");
+            else                   fprintf(cf, "\tMatchUSBID      \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_driver, entry) {
-            fprintf(cf, "\tMatchDriver     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchDriver   \"");
+            else                   fprintf(cf, "\tMatchDriver     \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_tag, entry) {
-            fprintf(cf, "\tMatchTag        \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchTAG      \"");
+            else                   fprintf(cf, "\tMatchTAG        \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_layout, entry) {
-            fprintf(cf, "\tMatchLayout     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchLayout   \"");
+            else                   fprintf(cf, "\tMatchLayout     \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
-
         if (ptr->is_keyboard.set)
             fprintf(cf, "\tIsKeyboard      \"%s\"\n",
                     ptr->is_keyboard.val ? "yes" : "no");
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/Patterns.c.orig	2025-07-01 18:59:34.389220228 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/Patterns.c	2025-07-01 19:16:42.048489555 +0300
@@ -0,0 +1,177 @@
+/*
+ *  Utilities used by InputClass.c, OutputClass.c, and xf86platformBus.c
+ */
+
+static void
+free_group(xf86MatchGroup *group)
+{
+    xf86MatchPattern *pattern, *next_pattern;
+    xorg_list_for_each_entry_safe(pattern, next_pattern, &group->patterns, entry) {
+        xorg_list_del(&pattern->entry);
+        if (pattern->str)
+            free(pattern->str);
+#ifdef HAVE_REGEX_H
+        if ((pattern->mode == MATCH_IS_REGEX) && pattern->regex) {
+            regfree(pattern->regex);
+            free(pattern->regex);
+        }
+#endif
+        free(pattern);
+    }
+    free(group);
+}
+
+
+#define LOG_OR '|'
+#define LOG_AND '&'
+
+#define NEG_FLAG '!'
+
+#define REGEX_PREFIX "regex:"
+
+
+static
+xf86MatchGroup*
+create_group(const char *str, xf86MatchMode pref_mode,
+             Bool negated)
+ {
+    xf86MatchPattern *pattern;
+    xf86MatchGroup *group;
+    unsigned n;
+    static const char sep_or[2]  = { LOG_OR,  '\0' };
+    static const char sep_and[2] = { LOG_AND, '\0' };
+
+    if (!str)
+        return NULL;
+
+    group = malloc(sizeof(*group));
+    if (!group) return NULL;
+    xorg_list_init(&group->patterns);
+    group->is_negated = negated;
+
+  again:
+    /* start new pattern */
+    if ((pattern = malloc(sizeof(*pattern))) == NULL) {
+        free_group(group);
+        return NULL;
+    }
+    xorg_list_add(&pattern->entry, &group->patterns);
+
+    /* Pattern starting with '!' should NOT be matched */
+    if (*str == NEG_FLAG) {
+        pattern->is_negated = TRUE;
+        str++;
+    }
+    else
+        pattern->is_negated = FALSE;
+
+    pattern->str = NULL; 
+#ifdef HAVE_REGEX_H
+    pattern->regex = NULL;
+#endif
+
+    /* Check if there is a mode prefix */
+    if (!strncmp(str,REGEX_PREFIX,strlen(REGEX_PREFIX))) {
+        pattern->mode = MATCH_IS_REGEX;
+        str += strlen(REGEX_PREFIX);
+        if (*str) {
+            char *last;
+            last = strchr(str+1, *str);
+            if (last)
+                n = last-str-1;
+            else
+                n = strlen(str+1);
+            pattern->str = strndup(str+1, n);
+            *(pattern->str+n) = '\0';
+            str += n+1;
+            if (*str) str++;
+        }
+    }
+    else {
+        n = strcspn(str, sep_or);
+        if (n > strcspn(str, sep_and)) {
+            pattern->mode = MATCH_IS_SEQSTR;
+            pattern->str = malloc(n+2);
+            if (pattern->str) {
+                char *s, *d;
+                strncpy(pattern->str, str, n);
+                str += n;
+                *(pattern->str+n) = '\0';
+                s = d = pattern->str;
+                n = 0;
+              next_chunk:
+                while ((*s) && (*s != LOG_AND)) {
+                    if (n == -1) {
+                        *(d++) = '\0';
+                        n = 0;
+                    }
+                    *(d++) = *(s++);
+                    n++;
+                }
+                while ((*s) == LOG_AND) s++;
+                if (*s) {
+                    n = -1;
+                    goto next_chunk;
+                }
+                *(++d) = '\0';
+            }
+            else
+                str += n;
+        }
+        else {
+            pattern->mode = pref_mode;
+            pattern->str = strndup(str, n);
+            *(pattern->str+n) = '\0';
+            str += n;
+        }
+    }
+
+    if (pattern->str == NULL)
+        pattern->mode = MATCH_IS_INVALID;
+
+    if (*str == LOG_OR)
+        str++;
+
+    if (*str)
+        goto again;
+
+    return group;
+}
+
+static void
+print_pattern(FILE * cf, const xf86MatchPattern *pattern, Bool not_first)
+{
+    if (!pattern) return;
+    if (not_first)
+        fprintf(cf, "%c", LOG_OR);
+    if (pattern->is_negated)
+        fprintf(cf, "%c", NEG_FLAG);
+    if (pattern->mode == MATCH_IS_INVALID)
+        fprintf(cf, "invalid:");
+    else
+    if (pattern->mode == MATCH_IS_REGEX) {
+    /* FIXME: Hope there is no '%' in the pattern */
+        if (pattern->str)
+            fprintf(cf, REGEX_PREFIX "%%%s%%", pattern->str);
+        else
+            fprintf(cf, REGEX_PREFIX "%%(none)%%");
+    }
+    else if (pattern->mode == MATCH_IS_SEQSTR) {
+        Bool after = FALSE;
+        char *str = pattern->str;
+        while (*str) {
+            if (after)
+                fprintf(cf, "%c", LOG_AND);
+            fprintf(cf, "%s", str);
+            str += strlen(str);
+            str++;
+            after = TRUE;
+        }
+    }
+    else {
+        if (pattern->str)
+            fprintf(cf, "%s", pattern->str);
+        else
+            fprintf(cf, "(none)");
+    }
+}
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/OutputClass.c.orig	2025-06-24 18:46:26.000000000 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/OutputClass.c	2025-07-01 18:59:34.390429992 +0300
@@ -44,6 +44,8 @@
     {-1, ""},
 };
 
+#include "Patterns.c"
+
 static void
 xf86freeOutputClassList(XF86ConfOutputClassPtr ptr)
 {
@@ -51,7 +53,6 @@
 
     while (ptr) {
         xf86MatchGroup *group, *next;
-        char **list;
 
         TestFree(ptr->identifier);
         TestFree(ptr->comment);
@@ -59,13 +60,8 @@
         TestFree(ptr->modulepath);
 
         xorg_list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
-            for (list = group->values; *list; list++) {
-                free(*list);
-                *list = NULL;
-            }
             xorg_list_del(&group->entry);
-            free(group);
-            group = NULL;
+            free_group(group);
         }
 
         xf86optionListFree(ptr->option_lst);
@@ -78,23 +74,12 @@
 
 #define CLEANUP xf86freeOutputClassList
 
-#define TOKEN_SEP "|"
-
-static void
-add_group_entry(struct xorg_list *head, char **values)
-{
-    xf86MatchGroup *group = calloc(1, sizeof(xf86MatchGroup));
-    if (group) {
-        group->values = values;
-        xorg_list_add(&group->entry, head);
-    }
-}
-
 XF86ConfOutputClassPtr
 xf86parseOutputClassSection(void)
 {
     int has_ident = FALSE;
     int token;
+    xf86MatchGroup *group;
 
     parsePrologue(XF86ConfOutputClassPtr, XF86ConfOutputClassRec)
 
@@ -141,9 +126,12 @@
         case MATCH_DRIVER:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchDriver");
-            add_group_entry(&ptr->match_driver,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
-            free(xf86_lex_val.str);
+            else {
+                group = create_group(xf86_lex_val.str, MATCH_IS_STRCMP, FALSE);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_driver);
+                free(xf86_lex_val.str);
+            }
             break;
         case EOF_TOKEN:
             Error(UNEXPECTED_EOF_MSG);
@@ -163,11 +151,13 @@
 
     return ptr;
 }
+
 void
 xf86printOutputClassSection(FILE * cf, XF86ConfOutputClassPtr ptr)
 {
     const xf86MatchGroup *group;
-    char *const *cur;
+    const xf86MatchPattern *pattern;
+    Bool not_first;
 
     while (ptr) {
         fprintf(cf, "Section \"OutputClass\"\n");
@@ -180,9 +170,11 @@
 
         xorg_list_for_each_entry(group, &ptr->match_driver, entry) {
             fprintf(cf, "\tMatchDriver     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                print_pattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
 
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/xf86Parser.h.orig	2025-06-24 18:46:26.000000000 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/parser/xf86Parser.h	2025-07-01 19:02:04.191341676 +0300
@@ -67,6 +67,11 @@
 #include "xf86Optrec.h"
 #include "list.h"
 
+#include <sys/types.h>
+#ifdef HAVE_REGEX_H
+#include <regex.h>
+#endif
+
 #define HAVE_PARSER_DECLS
 
 typedef struct {
@@ -304,10 +309,32 @@
 
 typedef struct {
     struct xorg_list entry;
-    char **values;
+    struct xorg_list patterns;
     Bool is_negated;
 } xf86MatchGroup;
 
+typedef enum {
+    MATCH_IS_INVALID,
+    MATCH_IS_STRCMP,
+    MATCH_IS_STRCASECMP,
+    MATCH_IS_STRSTR,
+    MATCH_IS_STRCASESTR,
+    MATCH_IS_FILENAME,
+    MATCH_IS_PATHNAME,
+    MATCH_IS_SEQSTR,
+    MATCH_IS_REGEX
+} xf86MatchMode;
+
+typedef struct {
+    struct xorg_list entry;
+    xf86MatchMode mode;
+    Bool is_negated;
+    char *str;
+#ifdef HAVE_REGEX_H
+    regex_t *regex;
+#endif
+} xf86MatchPattern;
+
 typedef struct {
     GenericListRec list;
     char *identifier;
--- xserver-xlibre-xserver-25.0.0.1/hw/xfree86/man/xorg.conf.man.orig	2025-06-24 18:46:26.000000000 +0300
+++ xserver-xlibre-xserver-25.0.0.1/hw/xfree86/man/xorg.conf.man	2025-07-01 18:59:34.388625389 +0300
@@ -1174,6 +1174,25 @@
 directives. These NoMatch directives match if the subsequent match is not
 met by the device.
 .PP
+To apply more sophicticated conditions, an entire attribute can be matched
+against an extended regular expression (see
+.BR regex (7)
+):
+.PP
+.RS 4
+.nf
+.B  "    # product string must start with Experimental
+.B  "    # and end with Device
+.B  "    MatchProduct \*qregex:_^Experimental.*Device$_\*q"
+.fi
+.RE
+.PP
+Such a pattern is prefixed with "regex:", and the next character, which
+may be arbitrary, is used as a two-side delimiter, i.e. the regular
+expression starts after it and lasts until its next occurrence, or to
+the end of the argument, if the delimiting character has not been found
+again.
+.PP
 The second type of entry is used to match device types. These entries take a
 boolean argument similar to
 .B Option
--- xserver-xlibre-xserver-25.0.0.1/include/meson.build.orig	2025-07-01 18:51:31.711516699 +0300
+++ xserver-xlibre-xserver-25.0.0.1/include/meson.build	2025-07-01 18:53:02.756706903 +0300
@@ -132,6 +132,7 @@
 conf_data.set('HAVE_FNMATCH_H', cc.has_header('fnmatch.h') ? '1' : false)
 conf_data.set('HAVE_LINUX_AGPGART_H', cc.has_header('linux/agpgart.h') ? '1' : false)
 conf_data.set('HAVE_STRINGS_H', cc.has_header('strings.h') ? '1' : false)
+conf_data.set('HAVE_REGEX_H', cc.has_header('regex.h') ? '1' : false)
 conf_data.set('HAVE_SYS_AGPGART_H', cc.has_header('sys/agpgart.h') ? '1' : false)
 conf_data.set('HAVE_SYS_UCRED_H', cc.has_header('sys/ucred.h') ? '1' : false)
 conf_data.set('HAVE_SYS_UN_H', cc.has_header('sys/un.h') ? '1' : false)

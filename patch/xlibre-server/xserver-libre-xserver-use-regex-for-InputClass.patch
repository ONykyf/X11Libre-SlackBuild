diff --git a/hw/xfree86/common/xf86Xinput.c b/hw/xfree86/common/xf86Xinput.c
index 5511507dd..bd9334038 100644
--- a/hw/xfree86/common/xf86Xinput.c
+++ b/hw/xfree86/common/xf86Xinput.c
@@ -529,82 +529,115 @@ HostOS(void)
 #endif
 }
 
-static int
-match_substring(const char *attr, const char *pattern)
-{
-    return (strstr(attr, pattern)) ? 0 : -1;
-}
+/*
+ * Match an attribute against a pattern. Matching mode is
+ * determined by pattern->mode member. If the mode is REGEX,
+ * then regex_t is allocated and compiled only during
+ * the first call, to save time and memory.
+ */
 
-#ifdef HAVE_FNMATCH_H
 static int
-match_pattern(const char *attr, const char *pattern)
+match_token(const char *attr, xf86MatchPattern *pattern)
 {
-    return fnmatch(pattern, attr, 0);
-}
+    if ((!pattern) || (!attr))
+        return 0;
+
+    switch (pattern->mode)
+    {
+        case MATCH_IS_INVALID:
+            return 0;
+        case MATCH_IS_STRCMP:
+            return (strcmp(attr, pattern->str)) ? 0 : -1;
+        case MATCH_IS_STRCASECMP:
+            return (strcasecmp(attr, pattern->str)) ? 0 : -1;
+        case MATCH_IS_STRSTR:
+            return (strstr(attr, pattern->str)) ? -1 : 0;
+        case MATCH_IS_STRCASESTR:
+            return (strcasestr(attr, pattern->str)) ? -1 : 0;
+#ifdef HAVE_FNMATCH_H
+        case MATCH_IS_FILENAME:
+            return (fnmatch(pattern->str, attr, 0)) ? 0 : -1;
+        case MATCH_IS_PATHNAME:
+            return (fnmatch(pattern->str, attr, FNM_PATHNAME)) ? 0 : -1;
 #else
-#define match_pattern match_substring
+        case MATCH_IS_FILENAME:
+            return (strstr(attr, pattern->str)) ? -1 : 0;
+        case MATCH_IS_PATHNAME:
+            return (strstr(attr, pattern->str)) ? -1 : 0;
 #endif
-
-#ifdef HAVE_FNMATCH_H
-static int
-match_path_pattern(const char *attr, const char *pattern)
-{
-    return fnmatch(pattern, attr, FNM_PATHNAME);
-}
+        case MATCH_IS_SEQSTR:
+            {
+                char* str = pattern->str;
+                while (*str) {
+                    attr=strstr(attr, str);
+                    if (!attr) return 0;
+                    attr += strlen(str);
+                    str += strlen(str);
+                    str++;
+                }
+            }
+            return -1;
+        case MATCH_IS_REGEX:
+        default:
+#ifdef HAVE_REGEX_H
+            if (pattern->regex == NULL) {
+                int r;
+                if ((pattern->regex = malloc(sizeof(regex_t))) == NULL) {
+                    pattern->mode = MATCH_IS_INVALID;
+                    return 0;
+                }
+                r = regcomp(pattern->regex, pattern->str, REG_EXTENDED | REG_NOSUB);
+                if (r) { /* Wrong regex */
+                    regfree(pattern->regex);
+                    free(pattern->regex);
+                    xf86Msg(X_ERROR, "Wrong regex: \"%s\"\n", pattern->str);
+                    pattern->mode = MATCH_IS_INVALID;
+                    return 0;
+                }
+            }
+            return (regexec(pattern->regex, attr,0, NULL, 0)) ? 0 : -1;
 #else
-#define match_path_pattern match_substring
+            xf86Msg(X_ERROR, "Regex is unavailable at this system: \"%s\"\n", pattern->str);
+            pattern->mode = MATCH_IS_INVALID;
+            return 0;
 #endif
-
-/*
- * If no Layout section is found, xf86ServerLayout.id becomes "(implicit)"
- * It is convenient that "" in patterns means "no explicit layout"
- */
-static int
-match_string_implicit(const char *attr, const char *pattern)
-{
-    if (strlen(pattern)) {
-        return strcmp(attr, pattern);
-    }
-    else {
-        return strcmp(attr, "(implicit)");
     }
 }
 
 /*
- * Match an attribute against a list of NULL terminated arrays of patterns.
- * If a pattern in each list entry is matched, return TRUE.
+ * Match an attribute against a list of xf86MatchGroup's.
+ * Return TRUE only if each list entry is successful.
  */
-static Bool
-MatchAttrToken(const char *attr, struct xorg_list *patterns,
-               int (*compare) (const char *attr, const char *pattern))
+Bool
+MatchAttrToken(const char *attr, struct xorg_list *groups)
 {
-    const xf86MatchGroup *group;
+    xf86MatchGroup *group;
+    xf86MatchPattern *pattern;
 
-    /* If there are no patterns, accept the match */
-    if (xorg_list_is_empty(patterns))
+    /* If there are no groups, accept the match */
+    if (xorg_list_is_empty(groups))
         return TRUE;
 
+    /* If there are groups but no attribute, reject the match */
+    if (!attr)
+        return FALSE;
+
     /*
-     * Iterate the list of patterns ensuring each entry has a
-     * match. Each list entry is a separate Match line of the same type.
+     * Otherwise, iterate the list of groups ensuring each entry has a
+     * match. Each list entry is a list of patterns obtained from
+     * a separate Match line.
      */
-    xorg_list_for_each_entry(group, patterns, entry) {
-        char *const *cur;
-        Bool is_negated = group->is_negated;
-        Bool match = is_negated;
-
-        /* If there's a pattern but no attribute, we reject the match for a
-         * MatchFoo directive, and accept it for a NoMatchFoo directive
-         */
-        if (!attr)
-            return is_negated;
-
-        for (cur = group->values; *cur; cur++)
-            if ((*compare) (attr, *cur) == 0) {
-                match = !is_negated;
-                break;
-            }
-        if (!match)
+    xorg_list_for_each_entry(group, groups, entry) {
+        Bool match = FALSE;
+
+        xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+            /* It is enough to find one pattern matched by the attribute */
+            match = ((!match_token(attr, pattern)) == pattern->is_negated);
+            if (match)
+                goto group_done;
+        }
+      group_done:
+        if (match == group->is_negated)
             return FALSE;
     }
 
@@ -612,6 +645,7 @@ MatchAttrToken(const char *attr, struct xorg_list *patterns,
     return TRUE;
 }
 
+
 /*
  * Classes without any Match statements match all devices. Otherwise, all
  * statements must match.
@@ -620,34 +654,34 @@ static Bool
 InputClassMatches(const XF86ConfInputClassPtr iclass, const InputInfoPtr idev,
                   const InputAttributes * attrs)
 {
+    const char *layout;
+
     /* MatchProduct substring */
-    if (!MatchAttrToken
-        (attrs->product, &iclass->match_product, match_substring))
+    if (!MatchAttrToken(attrs->product, &iclass->match_product))
         return FALSE;
 
     /* MatchVendor substring */
-    if (!MatchAttrToken(attrs->vendor, &iclass->match_vendor, match_substring))
+    if (!MatchAttrToken(attrs->vendor, &iclass->match_vendor))
         return FALSE;
 
     /* MatchDevicePath pattern */
-    if (!MatchAttrToken
-        (attrs->device, &iclass->match_device, match_path_pattern))
+    if (!MatchAttrToken(attrs->device, &iclass->match_device))
         return FALSE;
 
     /* MatchOS case-insensitive string */
-    if (!MatchAttrToken(HostOS(), &iclass->match_os, strcasecmp))
+    if (!MatchAttrToken(HostOS(), &iclass->match_os))
         return FALSE;
 
     /* MatchPnPID pattern */
-    if (!MatchAttrToken(attrs->pnp_id, &iclass->match_pnpid, match_pattern))
+    if (!MatchAttrToken(attrs->pnp_id, &iclass->match_pnpid))
         return FALSE;
 
     /* MatchUSBID pattern */
-    if (!MatchAttrToken(attrs->usb_id, &iclass->match_usbid, match_pattern))
+    if (!MatchAttrToken(attrs->usb_id, &iclass->match_usbid))
         return FALSE;
 
     /* MatchDriver string */
-    if (!MatchAttrToken(idev->driver, &iclass->match_driver, strcmp))
+    if (!MatchAttrToken(idev->driver, &iclass->match_driver))
         return FALSE;
 
     /*
@@ -661,7 +695,7 @@ InputClassMatches(const XF86ConfInputClassPtr iclass, const InputInfoPtr idev,
         if (!attrs->tags)
             return FALSE;
         for (tag = attrs->tags, match = FALSE; *tag; tag++) {
-            if (MatchAttrToken(*tag, &iclass->match_tag, strcmp)) {
+            if (MatchAttrToken(*tag, &iclass->match_tag)) {
                 match = TRUE;
                 break;
             }
@@ -670,12 +704,17 @@ InputClassMatches(const XF86ConfInputClassPtr iclass, const InputInfoPtr idev,
             return FALSE;
     }
 
-    /* MatchLayout string */
-    if (!xorg_list_is_empty(&iclass->match_layout)) {
-        if (!MatchAttrToken(xf86ConfigLayout.id,
-                            &iclass->match_layout, match_string_implicit))
+    /* MatchLayout string
+     *
+     * If no Layout section is found, xf86ServerLayout.id becomes "(implicit)"
+     * It is convenient that "" in patterns means "no explicit layout"
+     */
+    if (strcmp(xf86ConfigLayout.id,"(implicit)"))
+        layout = xf86ConfigLayout.id;
+    else
+        layout = "";
+    if (!MatchAttrToken(layout, &iclass->match_layout))
             return FALSE;
-    }
 
     /* MatchIs* booleans */
     if (iclass->is_keyboard.set &&
diff --git a/hw/xfree86/common/xf86Xinput_priv.h b/hw/xfree86/common/xf86Xinput_priv.h
index 7f0ec46fa..a62556978 100644
--- a/hw/xfree86/common/xf86Xinput_priv.h
+++ b/hw/xfree86/common/xf86Xinput_priv.h
@@ -22,4 +22,6 @@ void xf86AddInputEventDrainCallback(CallbackProcPtr callback, void *param);
 
 void xf86RemoveInputEventDrainCallback(CallbackProcPtr callback, void *param);
 
+Bool MatchAttrToken(const char *attr, struct xorg_list *groups);
+
 #endif /* _XSERVER__XF86XINPUT_H */
diff --git a/hw/xfree86/common/xf86platformBus.c b/hw/xfree86/common/xf86platformBus.c
index f2fb4bd97..13b6450bd 100644
--- a/hw/xfree86/common/xf86platformBus.c
+++ b/hw/xfree86/common/xf86platformBus.c
@@ -37,6 +37,10 @@
 #include <fcntl.h>
 #include <unistd.h>
 
+#ifdef HAVE_FNMATCH_H
+#include <fnmatch.h>
+#endif
+
 #include "config/hotplug_priv.h"
 #include "dix/screenint_priv.h"
 #include "randr/randrstr_priv.h"
@@ -54,6 +58,7 @@
 #include "xf86Bus.h"
 #include "Pci.h"
 #include "xf86platformBus.h"
+#include "xf86Xinput_priv.h"
 #include "xf86Config.h"
 #include "xf86Crtc.h"
 
@@ -176,50 +181,13 @@ xf86_check_platform_slot(const struct xf86_platform_device *pd)
     return TRUE;
 }
 
-static Bool
-MatchToken(const char *value, struct xorg_list *patterns,
-           int (*compare)(const char *, const char *))
-{
-    const xf86MatchGroup *group;
-
-    /* If there are no patterns, accept the match */
-    if (xorg_list_is_empty(patterns))
-        return TRUE;
-
-    /* If there are patterns but no attribute, reject the match */
-    if (!value)
-        return FALSE;
-
-    /*
-     * Otherwise, iterate the list of patterns ensuring each entry has a
-     * match. Each list entry is a separate Match line of the same type.
-     */
-    xorg_list_for_each_entry(group, patterns, entry) {
-        Bool match = FALSE;
-        char *const *cur;
-
-        for (cur = group->values; *cur; cur++) {
-            if ((*compare)(value, *cur) == 0) {
-                match = TRUE;
-                break;
-            }
-        }
-
-        if (!match)
-            return FALSE;
-    }
-
-    /* All the entries in the list matched the attribute */
-    return TRUE;
-}
-
 static Bool
 OutputClassMatches(const XF86ConfOutputClassPtr oclass,
                    struct xf86_platform_device *dev)
 {
     char *driver = dev->attribs->driver;
 
-    if (!MatchToken(driver, &oclass->match_driver, strcmp))
+    if (!MatchAttrToken(driver, &oclass->match_driver))
         return FALSE;
 
     return TRUE;
diff --git a/hw/xfree86/man/xorg.conf.man b/hw/xfree86/man/xorg.conf.man
index b677f5d4a..f02b16015 100644
--- a/hw/xfree86/man/xorg.conf.man
+++ b/hw/xfree86/man/xorg.conf.man
@@ -1079,7 +1079,10 @@ There are two types of match entries used in
 .B InputClass
 sections. The first allows various tokens to be matched against attributes
 of the device. An entry can be constructed to match attributes from different
-devices by separating arguments with a '|' character. Multiple entries of the
+devices by separating arguments with a '|' character. If an argument is prepended
+with '!', then it should NOT be contained in an attribute. If one or more '&'
+characters are present in an argument, they split it into parts that ALL must
+be substrings of an attribute. Multiple entries of the
 same type may be supplied to add multiple matching conditions on the same
 attribute. For example:
 .PP
@@ -1087,10 +1090,10 @@ attribute. For example:
 .nf
 .B  "Section \*qInputClass\*q"
 .B  "    Identifier   \*qMy Class\*q"
-.B  "    # product string must contain example and"
-.B  "    # either gizmo or gadget"
-.B  "    MatchProduct \*qexample\*q"
-.B  "    MatchProduct \*qgizmo\^|\^gadget\*q"
+.B  "    # product string must not contain example and"
+.B  "    # contain either both gizmo and gremlin, or gadget"
+.B  "    MatchProduct \*q!example\*q"
+.B  "    MatchProduct \*qgizmo\^&\^gremlin\^|\^gadget\*q"
 .B  "    NoMatchDriver \*qdrivername\*q"
 .I  "    \&.\|.\|.\&"
 .B  EndSection
@@ -1174,6 +1177,25 @@ and
 directives. These NoMatch directives match if the subsequent match is not
 met by the device.
 .PP
+To apply more sophicticated conditions, an entire attribute can be matched
+against an extended regular expression (see
+.BR regex (7)
+):
+.PP
+.RS 4
+.nf
+.B  "    # product string must start with Experimental
+.B  "    # and end with Device
+.B  "    MatchProduct \*qregex:_^Experimental.*Device$_\*q"
+.fi
+.RE
+.PP
+Such a pattern is prefixed with "regex:", and the next character, which
+may be arbitrary, is used as a two-side delimiter, i.e. the regular
+expression starts after it and lasts until its next occurrence, or to
+the end of the argument, if the delimiting character has not been found
+again.
+.PP
 The second type of entry is used to match device types. These entries take a
 boolean argument similar to
 .B Option
diff --git a/hw/xfree86/parser/InputClass.c b/hw/xfree86/parser/InputClass.c
index 49a324b18..249efa9c7 100644
--- a/hw/xfree86/parser/InputClass.c
+++ b/hw/xfree86/parser/InputClass.c
@@ -77,64 +77,45 @@ xf86freeInputClassList(XF86ConfInputClassPtr ptr)
 
     while (ptr) {
         xf86MatchGroup *group, *next;
-        char **list;
 
         TestFree(ptr->identifier);
         TestFree(ptr->driver);
 
         xorg_list_for_each_entry_safe(group, next, &ptr->match_product, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_vendor, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_device, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_os, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_pnpid, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_usbid, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_tag, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
         xorg_list_for_each_entry_safe(group, next, &ptr->match_layout, entry) {
             xorg_list_del(&group->entry);
-            for (list = group->values; *list; list++)
-                free(*list);
-            free(group);
+            xf86freeGroup(group);
         }
 
         TestFree(ptr->comment);
@@ -148,30 +129,13 @@ xf86freeInputClassList(XF86ConfInputClassPtr ptr)
 
 #define CLEANUP xf86freeInputClassList
 
-#define TOKEN_SEP "|"
-
-enum MatchType {
-    MATCH_NORMAL,
-    MATCH_NEGATED,
-};
-
-static void
-add_group_entry(struct xorg_list *head, char **values, enum MatchType type)
-{
-    xf86MatchGroup *group = calloc(1, sizeof(xf86MatchGroup));
-    if (group) {
-        group->is_negated = (type == MATCH_NEGATED);
-        group->values = values;
-        xorg_list_add(&group->entry, head);
-    }
-}
-
 XF86ConfInputClassPtr
 xf86parseInputClassSection(void)
 {
     int has_ident = FALSE;
     int token;
-    enum MatchType matchtype;
+    Bool negated;
+    xf86MatchGroup *group;
 
     parsePrologue(XF86ConfInputClassPtr, XF86ConfInputClassRec)
 
@@ -187,7 +151,7 @@ xf86parseInputClassSection(void)
     xorg_list_init(&ptr->match_layout);
 
     while ((token = xf86getToken(InputClassTab)) != ENDSECTION) {
-        matchtype = MATCH_NORMAL;
+        negated = FALSE;
 
         switch (token) {
         case COMMENT:
@@ -217,103 +181,121 @@ xf86parseInputClassSection(void)
             ptr->option_lst = xf86parseOption(ptr->option_lst);
             break;
         case NOMATCH_PRODUCT:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_PRODUCT:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchProduct");
-            add_group_entry(&ptr->match_product,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRSTR, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_product);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_VENDOR:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_VENDOR:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchVendor");
-            add_group_entry(&ptr->match_vendor,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRSTR, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_vendor);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_DEVICE_PATH:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_DEVICE_PATH:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchDevicePath");
-            add_group_entry(&ptr->match_device,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_PATHNAME, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_device);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_OS:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_OS:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchOS");
-            add_group_entry(&ptr->match_os, xstrtokenize(xf86_lex_val.str,
-                                                         TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRCASECMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_os);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_PNPID:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_PNPID:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchPnPID");
-            add_group_entry(&ptr->match_pnpid,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_FILENAME, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_pnpid);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_USBID:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_USBID:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchUSBID");
-            add_group_entry(&ptr->match_usbid,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_FILENAME, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_usbid);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_DRIVER:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_DRIVER:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchDriver");
-            add_group_entry(&ptr->match_driver,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRCMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_driver);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_TAG:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_TAG:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchTag");
-            add_group_entry(&ptr->match_tag, xstrtokenize(xf86_lex_val.str,
-                                                          TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRCMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_tag);
+                free(xf86_lex_val.str);
+            }
             break;
         case NOMATCH_LAYOUT:
-            matchtype = MATCH_NEGATED;
+            negated = TRUE;
             /* fallthrough */
         case MATCH_LAYOUT:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchLayout");
-            add_group_entry(&ptr->match_layout,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP),
-                            matchtype);
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRCMP, negated);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_layout);
+                free(xf86_lex_val.str);
+            }
             break;
         case MATCH_IS_KEYBOARD:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
@@ -396,10 +378,11 @@ xf86parseInputClassSection(void)
 }
 
 void
-xf86printInputClassSection(FILE * cf, XF86ConfInputClassPtr ptr)
+xf86printInputClassSection (FILE * cf, XF86ConfInputClassPtr ptr)
 {
     const xf86MatchGroup *group;
-    char *const *cur;
+    const xf86MatchPattern *pattern;
+    Bool not_first;
 
     while (ptr) {
         fprintf(cf, "Section \"InputClass\"\n");
@@ -411,69 +394,95 @@ xf86printInputClassSection(FILE * cf, XF86ConfInputClassPtr ptr)
             fprintf(cf, "\tDriver          \"%s\"\n", ptr->driver);
 
         xorg_list_for_each_entry(group, &ptr->match_product, entry) {
-            fprintf(cf, "\tMatchProduct    \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchProduct  \"");
+            else                   fprintf(cf, "\tMatchProduct    \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_vendor, entry) {
-            fprintf(cf, "\tMatchVendor     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchVendor   \"");
+            else                   fprintf(cf, "\tMatchVendor     \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_device, entry) {
-            fprintf(cf, "\tMatchDevicePath \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchDevicePath \"");
+            else                   fprintf(cf, "\tMatchDevicePath   \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_os, entry) {
-            fprintf(cf, "\tMatchOS         \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchOS       \"");
+            else                   fprintf(cf, "\tMatchOS         \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_pnpid, entry) {
-            fprintf(cf, "\tMatchPnPID      \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchPnPID    \"");
+            else                   fprintf(cf, "\tMatchPnPID      \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_usbid, entry) {
-            fprintf(cf, "\tMatchUSBID      \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchUSBID    \"");
+            else                   fprintf(cf, "\tMatchUSBID      \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_driver, entry) {
-            fprintf(cf, "\tMatchDriver     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchDriver   \"");
+            else                   fprintf(cf, "\tMatchDriver     \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_tag, entry) {
-            fprintf(cf, "\tMatchTag        \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchTAG      \"");
+            else                   fprintf(cf, "\tMatchTAG        \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
         xorg_list_for_each_entry(group, &ptr->match_layout, entry) {
-            fprintf(cf, "\tMatchLayout     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            if (group->is_negated) fprintf(cf, "\tNoMatchLayout   \"");
+            else                   fprintf(cf, "\tMatchLayout     \"");
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
-
         if (ptr->is_keyboard.set)
             fprintf(cf, "\tIsKeyboard      \"%s\"\n",
                     ptr->is_keyboard.val ? "yes" : "no");
diff --git a/hw/xfree86/parser/OutputClass.c b/hw/xfree86/parser/OutputClass.c
index cd9a19179..e5d234c1a 100644
--- a/hw/xfree86/parser/OutputClass.c
+++ b/hw/xfree86/parser/OutputClass.c
@@ -51,7 +51,6 @@ xf86freeOutputClassList(XF86ConfOutputClassPtr ptr)
 
     while (ptr) {
         xf86MatchGroup *group, *next;
-        char **list;
 
         TestFree(ptr->identifier);
         TestFree(ptr->comment);
@@ -59,13 +58,8 @@ xf86freeOutputClassList(XF86ConfOutputClassPtr ptr)
         TestFree(ptr->modulepath);
 
         xorg_list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
-            for (list = group->values; *list; list++) {
-                free(*list);
-                *list = NULL;
-            }
             xorg_list_del(&group->entry);
-            free(group);
-            group = NULL;
+            xf86freeGroup(group);
         }
 
         xf86optionListFree(ptr->option_lst);
@@ -78,23 +72,12 @@ xf86freeOutputClassList(XF86ConfOutputClassPtr ptr)
 
 #define CLEANUP xf86freeOutputClassList
 
-#define TOKEN_SEP "|"
-
-static void
-add_group_entry(struct xorg_list *head, char **values)
-{
-    xf86MatchGroup *group = calloc(1, sizeof(xf86MatchGroup));
-    if (group) {
-        group->values = values;
-        xorg_list_add(&group->entry, head);
-    }
-}
-
 XF86ConfOutputClassPtr
 xf86parseOutputClassSection(void)
 {
     int has_ident = FALSE;
     int token;
+    xf86MatchGroup *group;
 
     parsePrologue(XF86ConfOutputClassPtr, XF86ConfOutputClassRec)
 
@@ -141,9 +124,12 @@ xf86parseOutputClassSection(void)
         case MATCH_DRIVER:
             if (xf86getSubToken(&(ptr->comment)) != XF86_TOKEN_STRING)
                 Error(QUOTE_MSG, "MatchDriver");
-            add_group_entry(&ptr->match_driver,
-                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
-            free(xf86_lex_val.str);
+            else {
+                group = xf86createGroup(xf86_lex_val.str, MATCH_IS_STRCMP, FALSE);
+                if (group)
+                    xorg_list_add(&group->entry, &ptr->match_driver);
+                free(xf86_lex_val.str);
+            }
             break;
         case EOF_TOKEN:
             Error(UNEXPECTED_EOF_MSG);
@@ -163,11 +149,13 @@ xf86parseOutputClassSection(void)
 
     return ptr;
 }
+
 void
 xf86printOutputClassSection(FILE * cf, XF86ConfOutputClassPtr ptr)
 {
     const xf86MatchGroup *group;
-    char *const *cur;
+    const xf86MatchPattern *pattern;
+    Bool not_first;
 
     while (ptr) {
         fprintf(cf, "Section \"OutputClass\"\n");
@@ -180,9 +168,11 @@ xf86printOutputClassSection(FILE * cf, XF86ConfOutputClassPtr ptr)
 
         xorg_list_for_each_entry(group, &ptr->match_driver, entry) {
             fprintf(cf, "\tMatchDriver     \"");
-            for (cur = group->values; *cur; cur++)
-                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
-                        *cur);
+            not_first = FALSE;
+            xorg_list_for_each_entry(pattern, &group->patterns, entry) {
+                xf86printPattern(cf, pattern, not_first);
+                not_first = TRUE;
+            }
             fprintf(cf, "\"\n");
         }
 
diff --git a/hw/xfree86/parser/configProcs.h b/hw/xfree86/parser/configProcs.h
index ef71c4d5a..4940939d5 100644
--- a/hw/xfree86/parser/configProcs.h
+++ b/hw/xfree86/parser/configProcs.h
@@ -140,6 +140,15 @@ xf86printExtensionsSection(FILE * cf, XF86ConfExtensionsPtr ptr);
 void
 xf86freeExtensions(XF86ConfExtensionsPtr ptr);
 
+/* pattern.c */
+void xf86freeGroup(xf86MatchGroup *group);
+xf86MatchGroup* xf86createGroup(const char *str,
+                                xf86MatchMode pref_mode,
+                                Bool negated);
+void xf86printPattern(FILE * cf,
+                      const xf86MatchPattern *pattern,
+                      Bool not_first);
+
 #ifdef HAVE_XORG_CONFIG_H
 #include <xorg-config.h>
 #endif
diff --git a/hw/xfree86/parser/meson.build b/hw/xfree86/parser/meson.build
index 031dc2bec..c1d54c3ea 100644
--- a/hw/xfree86/parser/meson.build
+++ b/hw/xfree86/parser/meson.build
@@ -12,6 +12,7 @@ srcs_xorg_parser = [
     'Pointer.c',
     'Screen.c',
     'Vendor.c',
+    'patterns.c',
     'read.c',
     'scan.c',
     'write.c',
diff --git a/hw/xfree86/parser/patterns.c b/hw/xfree86/parser/patterns.c
new file mode 100644
index 000000000..2cf0cac62
--- /dev/null
+++ b/hw/xfree86/parser/patterns.c
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2025 Oleh Nykyforchyn. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "misc.h"
+#include "xf86Parser.h"
+#include "configProcs.h"
+
+/*
+ *  Utilities used by InputClass.c and OutputClass.c
+ */
+
+/* A group (which is a struct xf86MatchGroup) represents a complex condition
+ * that should be satisfied if is_negated_is true or should not be satisfied
+ * otherwise, for an input or output device to be accepted. A group contains
+ * an xorg_list patterns.
+ *
+ * Each pattern (a struct xf86MatchPattern) is a subcondition. The logical value
+ * of a group is true if and only if at least one subcondition is true, i.e.,
+ * the patterns are combined by logical 'OR', which is represented by '|' in
+ * the string that defines a group.
+ *
+ * If string that defines a pattern is preceded by '!', then the logical
+ * value of the pattern is negated. Note that a second * '!' does not cancel
+ * the first one, so '!!' does not make sense.
+ *
+ * A string correponding to a pattern can be treated either as a regular
+ * expression (if it is prepended by the prefix "regex:", then the next
+ * character is a double-sided delimiter), or as a string with which an attribute
+ * of a device is compared. The mode of comparison is of the type 
+ * enum xf86MatchMode and depends on the type of the attribute.
+ *
+ * If a string is not a regex but contains one or more '&'s, then it is
+ * treated as a sequence of &'-separated substrings that should ALL be present
+ * in an attribute (in arbitrary places and order) for the logical value
+ * to be positive (so empty substrings are inessential and dropped).
+ * They are kept in pattern.str '\0'-separated, with a final second '\0'.
+ */
+
+
+void
+xf86freeGroup(xf86MatchGroup *group)
+{
+    xf86MatchPattern *pattern, *next_pattern;
+    xorg_list_for_each_entry_safe(pattern, next_pattern, &group->patterns, entry) {
+        xorg_list_del(&pattern->entry);
+        if (pattern->str)
+            free(pattern->str);
+#ifdef HAVE_REGEX_H
+        if ((pattern->mode == MATCH_IS_REGEX) && pattern->regex) {
+            regfree(pattern->regex);
+            free(pattern->regex);
+        }
+#endif
+        free(pattern);
+    }
+    free(group);
+}
+
+
+#define LOG_OR '|'
+#define LOG_AND '&'
+
+#define NEG_FLAG '!'
+
+#define REGEX_PREFIX "regex:"
+
+
+xf86MatchGroup*
+xf86createGroup(const char *str, xf86MatchMode pref_mode,
+             Bool negated)
+ {
+    xf86MatchPattern *pattern;
+    xf86MatchGroup *group;
+    unsigned n;
+    static const char sep_or[2]  = { LOG_OR,  '\0' };
+    static const char sep_and[2] = { LOG_AND, '\0' };
+
+    if (!str)
+        return NULL;
+
+    group = malloc(sizeof(*group));
+    if (!group) return NULL;
+    xorg_list_init(&group->patterns);
+    group->is_negated = negated;
+
+  again:
+    /* start new pattern */
+    if ((pattern = malloc(sizeof(*pattern))) == NULL)
+        goto fail;
+
+    xorg_list_add(&pattern->entry, &group->patterns);
+
+    /* Pattern starting with '!' should NOT be matched */
+    if (*str == NEG_FLAG) {
+        pattern->is_negated = TRUE;
+        str++;
+    }
+    else
+        pattern->is_negated = FALSE;
+
+    pattern->str = NULL;
+#ifdef HAVE_REGEX_H
+    pattern->regex = NULL;
+#endif
+
+    /* Check if there is a mode prefix */
+    if (!strncmp(str,REGEX_PREFIX,strlen(REGEX_PREFIX))) {
+        pattern->mode = MATCH_IS_REGEX;
+        str += strlen(REGEX_PREFIX);
+        if (*str) {
+            char *last;
+            last = strchr(str+1, *str);
+            if (last)
+                n = last-str-1;
+            else
+                n = strlen(str+1);
+            pattern->str = strndup(str+1, n);
+            if (pattern->str == NULL)
+                goto fail;
+            *(pattern->str+n) = '\0';
+            str += n+1;
+            if (*str) str++;
+        }
+    }
+    else {
+        n = strcspn(str, sep_or);
+        if (n > strcspn(str, sep_and)) {
+            pattern->mode = MATCH_IS_SEQSTR;
+            pattern->str = malloc(n+2);
+            if (pattern->str) {
+                char *s, *d;
+                strncpy(pattern->str, str, n);
+                str += n;
+                *(pattern->str+n) = '\0';
+                s = d = pattern->str;
+                n = 0;
+              next_chunk:
+                while ((*s) && (*s != LOG_AND)) {
+                    if (n == -1) {
+                        *(d++) = '\0';
+                        n = 0;
+                    }
+                    *(d++) = *(s++);
+                    n++;
+                }
+                while ((*s) == LOG_AND) s++;
+                if (*s) {
+                    n = -1;
+                    goto next_chunk;
+                }
+                if (d == pattern->str)
+                /* All chunks are empty */
+                    pattern->mode = MATCH_IS_INVALID;
+                *(++d) = '\0';
+            }
+            else
+                goto fail;
+        }
+        else {
+            pattern->mode = pref_mode;
+            pattern->str = strndup(str, n);
+            if (pattern->str == NULL)
+                goto fail;
+            *(pattern->str+n) = '\0'; /* should already be, but to be sure */
+            str += n;
+        }
+    }
+
+    while (*str == LOG_OR)
+        str++;
+
+    if (*str)
+        goto again;
+
+    return group;
+
+  fail:
+    xf86freeGroup(group);
+    return NULL;
+}
+
+void
+xf86printPattern(FILE * cf, const xf86MatchPattern *pattern, Bool not_first)
+{
+    if (!pattern) return;
+    if (not_first)
+        fprintf(cf, "%c", LOG_OR);
+    if (pattern->is_negated)
+        fprintf(cf, "%c", NEG_FLAG);
+    if (pattern->mode == MATCH_IS_INVALID)
+        fprintf(cf, "invalid:");
+    else
+    if (pattern->mode == MATCH_IS_REGEX) {
+    /* FIXME: Hope there is no '@' in the pattern */
+        if (pattern->str)
+            fprintf(cf, REGEX_PREFIX "@%s@", pattern->str);
+        else
+            fprintf(cf, REGEX_PREFIX "@(none)@");
+    }
+    else if (pattern->mode == MATCH_IS_SEQSTR) {
+        Bool after = FALSE;
+        char *str = pattern->str;
+        while (*str) {
+            if (after)
+                fprintf(cf, "%c", LOG_AND);
+            fprintf(cf, "%s", str);
+            str += strlen(str);
+            str++;
+            after = TRUE;
+        }
+    }
+    else {
+        if (pattern->str)
+            fprintf(cf, "%s", pattern->str);
+        else
+            fprintf(cf, "(none)");
+    }
+}
diff --git a/hw/xfree86/parser/xf86Parser.h b/hw/xfree86/parser/xf86Parser.h
index b9240af12..6748c0395 100644
--- a/hw/xfree86/parser/xf86Parser.h
+++ b/hw/xfree86/parser/xf86Parser.h
@@ -67,6 +67,11 @@
 #include "xf86Optrec.h"
 #include "list.h"
 
+#include <sys/types.h>
+#ifdef HAVE_REGEX_H
+#include <regex.h>
+#endif
+
 #define HAVE_PARSER_DECLS
 
 typedef struct {
@@ -304,10 +309,32 @@ typedef struct {
 
 typedef struct {
     struct xorg_list entry;
-    char **values;
+    struct xorg_list patterns;
     Bool is_negated;
 } xf86MatchGroup;
 
+typedef enum {
+    MATCH_IS_INVALID,
+    MATCH_IS_STRCMP,
+    MATCH_IS_STRCASECMP,
+    MATCH_IS_STRSTR,
+    MATCH_IS_STRCASESTR,
+    MATCH_IS_FILENAME,
+    MATCH_IS_PATHNAME,
+    MATCH_IS_SEQSTR,
+    MATCH_IS_REGEX
+} xf86MatchMode;
+
+typedef struct {
+    struct xorg_list entry;
+    xf86MatchMode mode;
+    Bool is_negated;
+    char *str;
+#ifdef HAVE_REGEX_H
+    regex_t *regex;
+#endif
+} xf86MatchPattern;
+
 typedef struct {
     GenericListRec list;
     char *identifier;
diff --git a/include/meson.build b/include/meson.build
index 1e9ed1950..0dea9745b 100644
--- a/include/meson.build
+++ b/include/meson.build
@@ -132,6 +132,7 @@ conf_data.set('HAVE_EXECINFO_H', cc.has_header('execinfo.h') ? '1' : false)
 conf_data.set('HAVE_FNMATCH_H', cc.has_header('fnmatch.h') ? '1' : false)
 conf_data.set('HAVE_LINUX_AGPGART_H', cc.has_header('linux/agpgart.h') ? '1' : false)
 conf_data.set('HAVE_STRINGS_H', cc.has_header('strings.h') ? '1' : false)
+conf_data.set('HAVE_REGEX_H', cc.has_header('regex.h') ? '1' : false)
 conf_data.set('HAVE_SYS_AGPGART_H', cc.has_header('sys/agpgart.h') ? '1' : false)
 conf_data.set('HAVE_SYS_UCRED_H', cc.has_header('sys/ucred.h') ? '1' : false)
 conf_data.set('HAVE_SYS_UN_H', cc.has_header('sys/un.h') ? '1' : false)
